\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\title{Compiler Documentation}
\author{Thomas Maloney \\ 
net-id \href{mailto:tmaloney@iastate.edu}{tmaloney@iastate.edu}}
\date{February 2021}

\begin{document}

\maketitle

\newcommand{\code}[1]{\texttt{#1}}

\section{Part 0 Documentation}
\subsection{main.c} 
\label{ssec:p0main}
This file contains the entry point of the compiler.
It passes the arguments from the command line to a method that parses them (described in section \ref{ssec:p0argparser}) and returns a \code{struct} that contains info about what flags were passed and what the possible output file might be (should that have been given).
I then check which flag got passed in and whether the output should be written to a provided file or just \code{stdout}.
The only \code{mode} flag that currently gets handled is \code{-0}.

\subsection{args\_parser} 
\label{ssec:p0argparser}
The header file contains a \code{struct}, an \code{enum} (both described in section \ref{ssec:p0datastructs}), and a method signature that gets implemented in \code{args\_parser.c}.
Here I use \code{getopt} from \code{unistd.h} to read/parse each flag and then record which flag and whether there was an output file to a \code{struct} that I return.
The potential output file gets passed back as an out-parameter.
If no flags were passed in, or one that doesn't exist, I print out the string that describes how to use the program to \code{stderr}.

\subsection{Data Structures} 
\label{ssec:p0datastructs}
There is one \code{struct} and one \code{enum} that have been defined so far:
\begin{itemize}
    \item (\code{struct}) \code{parsed\_args\_t}: This data type holds what \code{mode} flag gets passed in by way of the \code{mode\_e enum}.
    It also contains a flag that signals if there is a specific output file that should be written to instead of \code{stdout}.
    \item (\code{enum}) \code{mode\_e}: This just represents the possible \code{mode} flags that can be passed in plus an extra one that is set by default to make it easier to check if none of the required flags were passed in.
\end{itemize}

\section{Part 1 Documentation}
\subsection{main.c} 
\label{ssec:p1main}
For the most part, everything here is pretty similar to what's described in subsection \ref{ssec:p0main}.
That is, not much has really changed.
The one thing that has, however is that it now grabs the parsed file names that get stored in a \code{parsed\_args\_t} instance after which it sets a global variable equal to the array.
This allows the generated lexer file to access the list of files it needs to lex.

\subsection{lexer.l} 
\label{ssec:p1lexer}
Contains the regex rules for matching tokens.
There is also a function in it that allows \code{main.c} to set the starting input file from an \code{extern} string array that also gets pulled in from \code{main.c}.
Currently the lexer will just ignore preprocessor symbols. 

\subsection{log\_utils} 
\label{ssec:p1logutils}
Provides two function for logging data (info and errors) to the output stream, templated to match the assignment's specifications.

\subsection{args\_parser} 
\label{ssec:p1argparser}
Pretty similar to its implementation described in subsection \ref{ssec:p0argparser}.
A new feature in it is the ability to parse the input files from the command line and store them in an array.

\subsection{Data Structures} 
\label{ssec:p1datastructs}
There is one \code{struct} and one \code{enum} that have been defined so far:
\begin{itemize}
    \item (\code{struct}) \code{parsed\_args\_t}: This data type is still similar to how it is described in subsection \ref{ssec:p0datastructs}.
        It has only changed in that it now keeps track of the input files.
    \item (\code{enum}) \code{mode\_e}: Same as described in subsection \ref{ssec:p0datastructs}.
    \item (\code{enum}) \code{token\_e}: Enumerated list of syntax token types.
\end{itemize}
\end{document}
