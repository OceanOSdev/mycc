%skeleton "lalr1.cc" /* -*- C++ -*- */
%defines

%define api.token.constructor
%define api.value.type variant
%define parse.assert
%require "3.2"
%code requires
{
    #include <iostream>
    #include <string>
    #include <vector>
    #include <stdint.h>
    #include "syntax/symbols/variable_symbol.h"
    #include "syntax/symbols/parameter_symbol.h"
    #include "syntax/operator_tokens.h"
    #include "syntax/expression_node.h"
    #include "syntax/cast_expression_node.h"
    #include "syntax/ternary_expression_node.h"
    #include "syntax/binary_expression_node.h"
    #include "syntax/unary_expression_node.h"
    #include "syntax/call_expression_node.h"
    #include "syntax/name_expression_node.h"
    #include "syntax/index_expression_node.h"
    #include "syntax/member_expression_node.h"
    
    
    //namespace Syntax { class BinaryExpressionNode; }
    
     class Lexer;
     class Driver;

     void print_formal_param_list(std::vector<Syntax::ParameterSymbol> list);
}

%code top
{
    #include <iostream>
    #include <stdio.h>
    #include <string.h>
    #include "lexer.h"
    #include "mycc.tab.hpp"
    #include "driver.h"
    #include "location.hh"

    
    
    // yylex() arguments are defined in parser.y
    static yy::parser::symbol_type yylex(Lexer &lexer, Driver &driver) {
        return lexer.get_next_token();
    }
    
    // you can accomplish the same thing by inlining the code using preprocessor
    // x and y are same as in above static function
    // #define yylex(x, y) lexer.get_next_token()
    
}

%lex-param { Lexer &lexer }
%lex-param { Driver &driver }
%parse-param { Lexer &lexer }
%parse-param { Driver &driver }
%locations

%token END 0
%token <std::string> IDENT
%token <std::string> TYPE
%token CONST STRUCT 
%token <int> INTCONST 
%token <float> REALCONST 
%token <std::string> STRCONST 
%token <std::string> CHARCONST
%token FOR WHILE DO IF ELSE BREAK CONTINUE RETURN

%token LPAR RPAR LBRACKET RBRACKET LBRACE RBRACE
%token DOT COMMA SEMI QUEST COLON

%token <Syntax::SyntaxTokenType> PLUS
%token <Syntax::SyntaxTokenType> MINUS
%token <Syntax::SyntaxTokenType> STAR
%token <Syntax::SyntaxTokenType> SLASH
%token <Syntax::SyntaxTokenType> MOD
%token <Syntax::SyntaxTokenType> TILDE
%token <Syntax::SyntaxTokenType> PIPE
%token <Syntax::SyntaxTokenType> AMP
%token <Syntax::SyntaxTokenType> BANG
%token <Syntax::SyntaxTokenType> DPIPE
%token <Syntax::SyntaxTokenType> DAMP

%token <Syntax::SyntaxTokenType> ASSIGN
%token <Syntax::SyntaxTokenType> PLUSASSIGN
%token <Syntax::SyntaxTokenType> MINUSASSIGN
%token <Syntax::SyntaxTokenType> STARASSIGN
%token <Syntax::SyntaxTokenType> SLASHASSIGN
%token <Syntax::SyntaxTokenType> INCR
%token <Syntax::SyntaxTokenType> DECR

%token <Syntax::SyntaxTokenType> EQUALS
%token <Syntax::SyntaxTokenType> NEQUAL
%token <Syntax::SyntaxTokenType> GT
%token <Syntax::SyntaxTokenType> GE
%token <Syntax::SyntaxTokenType> LT
%token <Syntax::SyntaxTokenType> LE

%type <Syntax::ParameterSymbol> formal_param
%type <std::vector<Syntax::ParameterSymbol>> formal_param_list
%type <Syntax::ExpressionNode*> expr
%type <Syntax::BinaryExpressionNode*> bin_expr
%type <Syntax::UnaryExpressionNode*> un_expr
%type <std::vector<Syntax::ExpressionNode*>> nonzero_expr_list
%type <std::vector<Syntax::ExpressionNode*>> expr_list
%type <Syntax::ExpressionNode*> l_val

%nonassoc WITHOUT_ELSE
%nonassoc ELSE

%left COMMA
%left DOT
%right ASSIGN PLUSASSIGN MINUSASSIGN STARASSIGN SLASHASSIGN
%right QUEST COLON
%left DPIPE
%left DAMP
%left PIPE
%left AMP
%left EQUALS NEQUAL
%left LT LE GT GE
%left PLUS MINUS
%left STAR SLASH MOD
%right BANG TILDE UMINUS DECR INCR TYPE
%left LPAR RPAR LBRACKET RBRACKET

%%

prog : 
     | com_unit prog
     ;

com_unit : glob_var_decl                                              { }
         | glob_struct_def                                            { }
         | func_proto                                                 { }
         | func_def                                                   { }
         ;

glob_var_decl : var_decl;

glob_struct_def : struct_def;

func_proto : func_decl SEMI;

func_decl : TYPE IDENT LPAR formal_param_list RPAR                    { print_formal_param_list($4); /* function_name = $2;*/}
          | TYPE IDENT LPAR RPAR                                      {/* function_name = $2;*/}
          | CONST TYPE IDENT LPAR formal_param_list RPAR              {/* function_name = $3;*/}
          | CONST TYPE IDENT LPAR RPAR                                {/* function_name = $3;*/}
          | TYPE CONST IDENT LPAR formal_param_list RPAR              {/* function_name = $3;*/}
          | TYPE CONST IDENT LPAR RPAR                                {/* function_name = $3;*/}
          | STRUCT IDENT IDENT LPAR formal_param_list RPAR            {/* function_name = $3;*/}
          | STRUCT IDENT IDENT LPAR RPAR                              {/* function_name = $3;*/}
          | CONST STRUCT IDENT IDENT LPAR formal_param_list RPAR      {/* function_name = $4;*/}
          | CONST STRUCT IDENT IDENT LPAR RPAR                        {/* function_name = $4;*/}
          | STRUCT IDENT CONST IDENT LPAR formal_param_list RPAR      {/* function_name = $4;*/}
          | STRUCT IDENT CONST IDENT LPAR RPAR                        {/* function_name = $4;*/}
          ;

formal_param_list : formal_param                                      { Syntax::ParameterSymbol& p = $1; $$ = std::vector<Syntax::ParameterSymbol>(); $$.push_back(p); }
                  | formal_param_list COMMA formal_param              { Syntax::ParameterSymbol& p = $3; std::vector<Syntax::ParameterSymbol> &args = $1; args.push_back(p); $$ = args;}
                  ;

formal_param : TYPE IDENT                                             {$$ = Syntax::ParameterSymbol(false, $1, $2, false);}
             | TYPE IDENT LBRACKET RBRACKET                           {$$ = Syntax::ParameterSymbol(false, $1, $2, true);}
             | CONST TYPE IDENT                                       {$$ = Syntax::ParameterSymbol(true, $2, $3, false);}
             | CONST TYPE IDENT LBRACKET RBRACKET                     {$$ = Syntax::ParameterSymbol(true, $2, $3, true);}
             | TYPE CONST IDENT                                       {$$ = Syntax::ParameterSymbol(true, $1, $3, false);}
             | TYPE CONST IDENT LBRACKET RBRACKET                     {$$ = Syntax::ParameterSymbol(true, $1, $3, true);}
             | STRUCT IDENT IDENT                                     {$$ = Syntax::ParameterSymbol(false, "struct "+$2, $3, false);}
             | STRUCT IDENT IDENT LBRACKET RBRACKET                   {$$ = Syntax::ParameterSymbol(false, "struct "+$2, $3, true);}
             | CONST STRUCT IDENT IDENT                               {$$ = Syntax::ParameterSymbol(true, "struct "+$3, $4, false);}
             | CONST STRUCT IDENT IDENT LBRACKET RBRACKET             {$$ = Syntax::ParameterSymbol(true, "struct "+$3, $4, true);}
             | STRUCT IDENT CONST IDENT                               {$$ = Syntax::ParameterSymbol(true, "struct "+$2, $4, false);}
             | STRUCT IDENT CONST IDENT LBRACKET RBRACKET             {$$ = Syntax::ParameterSymbol(true, "struct "+$2, $4, true);}
             ;

func_def : func_decl LBRACE var_struct_decl_list stmt_list RBRACE            
         ;

struct_def : STRUCT IDENT LBRACE st_var_decl_list_na RBRACE SEMI      {}
           ;

stmts : stmt
      | stmt_block
      ;

stmt_block : LBRACE stmt_list RBRACE;

var_struct_decl_list :
                     | var_decl var_struct_decl_list
                     | struct_def var_struct_decl_list                
                     ;

st_var_decl_list_na : 
                    | st_var_decl_na st_var_decl_list_na
                    ;

st_var_decl_na : TYPE ident_list_na SEMI                              
               | CONST TYPE ident_list_na SEMI
               | TYPE CONST ident_list_na SEMI
               | STRUCT IDENT ident_list_na SEMI
               | CONST STRUCT IDENT ident_list_na SEMI
               | STRUCT IDENT CONST ident_list_na SEMI
               ; 

ident_list_na : ident_c
              | ident_c COMMA ident_list_na
              ;

ident_c : IDENT                                                       {/*append_svar_stack("%s",$1);*/}
        | IDENT LBRACKET INTCONST RBRACKET                            {/*append_svar_stack("%s[]",$1);*/}
        ;

stmt_list : 
          | stmt stmt_list
          ;

stmt : DO stmts WHILE LPAR expr RPAR SEMI
     | WHILE LPAR expr RPAR stmts
     | FOR LPAR opt_expr SEMI opt_expr SEMI opt_expr RPAR stmts
     | IF LPAR expr RPAR stmts %prec WITHOUT_ELSE
     | IF LPAR expr RPAR stmts ELSE stmts
     | RETURN opt_expr SEMI
     | BREAK SEMI
     | CONTINUE SEMI
     | expr SEMI
     | SEMI
     ;

opt_expr : 
         | expr
         ;

expr_list :                                                             { std::vector<Syntax::ExpressionNode*> l; $$ = l; }
          | nonzero_expr_list                                           { $$ = $1; }
          ;

nonzero_expr_list : expr                                                { Syntax::ExpressionNode* e = $1; $$ = std::vector<Syntax::ExpressionNode*>(); $$.push_back(e); }
                  | nonzero_expr_list COMMA expr                        { Syntax::ExpressionNode* e = $3; std::vector<Syntax::ExpressionNode*> &args = $1; args.push_back(e); $$ = args; }
                  ;

expr : LPAR expr RPAR                                                   { $$ = $2; }
     | LPAR TYPE RPAR expr                                              { $$ = new Syntax::CastExpressionNode($2, $4); }
     | expr QUEST expr COLON expr                                       { $$ = new Syntax::TernaryExpressionNode($1, $3, $5); }
     | bin_expr                                                         { $$ = $1; }
     | un_expr                                                          { $$ = $1; }
     | INCR l_val                                                       { $$ = nullptr; }
     | DECR l_val                                                       { $$ = nullptr; }
     | l_val INCR                                                       { $$ = nullptr; }
     | l_val DECR                                                       { $$ = nullptr; }
     | l_val assign_op expr %prec ASSIGN                                { $$ = nullptr; }
     | l_val                                                            { $$ = $1; }
     | IDENT LPAR expr_list RPAR                                        { $$ = new Syntax::CallExpressionNode($1, $3); }
     | literal_val                                                      { $$ = nullptr; }
     ;

l_val : IDENT                                                           { $$ = new Syntax::NameExpressionNode($1); }
      | IDENT LBRACKET expr RBRACKET                                    { $$ = new Syntax::IndexExpressionNode($1, $3); }
      | l_val DOT l_val                                                 { $$ = new Syntax::MemberExpressionNode($1, $3); }
      ;

un_expr : MINUS expr %prec UMINUS                                       { $$ = new Syntax::UnaryExpressionNode($1, $2); }
        | BANG expr                                                     { $$ = new Syntax::UnaryExpressionNode($1, $2); }
        | TILDE expr                                                    { $$ = new Syntax::UnaryExpressionNode($1, $2); }
        ;

bin_expr : expr DPIPE expr                                              { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr DAMP expr                                               { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr PIPE expr                                               { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr AMP expr                                                { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr EQUALS expr                                             { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr NEQUAL expr                                             { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr GT expr                                                 { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr GE expr                                                 { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr LT expr                                                 { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr LE expr                                                 { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr PLUS expr                                               { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr MINUS expr                                              { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr STAR expr                                               { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr SLASH expr                                              { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         | expr MOD expr                                                { $$ = new Syntax::BinaryExpressionNode($1, $2, $3); }
         ;

assign_op : ASSIGN
          | PLUSASSIGN
          | MINUSASSIGN
          | STARASSIGN
          | SLASHASSIGN
          ;

literal_val : INTCONST   {int val = $1; std::cout << "INTCONST: " << val << std::endl;}
            | REALCONST  {float val = $1; std::cout << "REALCONST: " << val << std::endl;}
            | STRCONST   {std::string &val = $1; std::cout << "STRCONST: " << val << std::endl;}
            | CHARCONST  {std::string &val = $1; std::cout << "CHARCONST: " << val << std::endl;}
            ;

var_decl : TYPE ident_list SEMI                                       
         | CONST TYPE ident_list SEMI
         | TYPE CONST ident_list SEMI
         | STRUCT IDENT ident_list SEMI
         | CONST STRUCT IDENT ident_list SEMI
         | STRUCT IDENT CONST ident_list SEMI
         ; 

ident_list : ident_ca
           | ident_ca COMMA ident_list
           ;

ident_ca : IDENT ASSIGN expr                                          {/*append_variable_stack("%s",$1);*/}
         | IDENT LBRACKET INTCONST RBRACKET ASSIGN expr               {/*append_variable_stack("%s[]",$1);*/}
         | IDENT                                                      {/*append_variable_stack("%s",$1);*/}
         | IDENT LBRACKET INTCONST RBRACKET                           {/*append_variable_stack("%s[]",$1);*/}
         ;

%%

void yy::parser::error(const location &loc , const std::string &message) {
        
        // Location should be initialized inside scanner action, but is not in this example.
        // Let's grab location directly from driver class.
	// cout << "Error: " << message << endl << "Location: " << loc << endl;
        std::cerr << "Error near " << driver.location().begin.filename 
                  << " line " << driver.location().begin.line 
                  << " text 'yytext'\n\t" << message << std::endl;	
        //std::cout << "Error: " << message << std::endl << "Error location: " << driver.location() << std::endl;
}

void print_formal_param_list(std::vector<Syntax::ParameterSymbol> list) {
        std::vector<Syntax::ParameterSymbol>::iterator iter;
    for( iter = list.begin(); iter != list.end(); iter++) {
        Syntax::ParameterSymbol p = *iter;
        std::cout << (p.constant() ? "const " : "") << p.var_type() << " " << p.var_name() << " " << (p.array() ? "[]" : "") << std::endl;
    }
}